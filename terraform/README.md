# Terraform

The persistent AWS infrastructure is deployed as Cloud.gov assets via Terraform. For a description of persistent infrastructure and how it differs from ephemeral infrastructure see the root README.md.

These docs are verbose because this is technology with which developers will rarely interact. I suggest you settle in for a nice long read with your favorite drink of choice.

## Set up

1. **Install terraform**

    On MacOS: `brew install terraform`
    On other platforms: [Download and install terraform][tf]

2. **Use githook for formatting**

    Terraform has a specific whitespace formatting style that is difficult to maintain. Terraform includes a formatting command, `terraform fmt`, to help developers maintain the correct style. This repository contains a pre-commit hook that runs `terraform fmt` on all staged files so you don't have to remember to run this command.

    If you are not using your own custom pre-commit hooks:

    ```bash
    # start from repo root directory
    # make the pre-commit file executable
    chmod 755 .githooks/pre-commit
    # change your default hooks directory to `.githooks`.
    git config core.hooksPath .githooks
    ```

    If you are already using git hooks, add the `.githooks/pre-commit` contents to your hooks directory or current pre-commit hook. Remember to make the file executable.

1. **Add service account credentials for your target environment**

    We are using Terraform to create Cloud Foundry resources in a Cloud.gov account. Creating infrastructure on the Cloud.gov platform requires a Cloud.gov service account username and password. These keys are specific to each cloud.gov organization/space, i.e. each deployment environment, and can be generated by developers who have proper Cloud.gov permissions at any time.

    You can use the same account credentials that are used to deploy applications via CircleCi or follow the steps below to generate a new set of credentials. If you need more information, check out the [service account docs][cloudgov-deployer].

    ```
    # login
    cf login -a api.fr.cloud.gov --sso
    # follow temporary authorization code prompts; select the org and space within which you want to build infrastructure

    # create a service instance that can provision service accounts
    cf create-service cloud-gov-service-account space-deployer < YOUR-DEPLOYER-NAME >

    # bind a service key to the service instance
    cf create-service-key < YOUR-DEPLOYER-NAME > space-deployer-key

    # return a username/password pair for the service instance
    cf service-key < YOUR-DEPLOYER-NAME > space-deployer-key
    ```

    Add the username and password output from the last command to a `secrets.auto.tfvars` file in each environment directory. Terraform automatically loads this variable definition file. You can also provide variable values via environment variables. For more on this, check out [terraform variable definitions][tf-vars].

    For example, your `terraform/dev/secrets.auto.tfvars` file should look something like this:

    ```
    cf_user = "some-dev-user"
    cf_password = "some-dev-password"
    ```

1. **Create a service account to interact with the S3 bucket**

    We are using an S3 bucket created by Cloud Foundry in Cloud.gov as our remote backend for Terraform. The backend maintains the "state" of Terraform and makes it possible for multiple developers to implement changes in a linear fashion.

    Follow these directions to create a new service account and generate credentials. If you need more information check out the [services docs][cloudgov-service-keys].

    ```
    # login
    cf login -a api.fr.cloud.gov --sso
    # follow temporary authorization code prompts; select org "hhs-acf-ohs-tta", space "infrastructure-config"

    # create a service instance
    cf create-service-key ohs-ttahub-iac-state < YOUR-NAME >

    # return a username/password pair for the service instance
    cf service-key ohs-ttahub-iac-state < YOUR-NAME >
    ```

    Add your `access_key_id` and `secret_access_key` to a `secrets.auto.tfvars` file in each environment directory. These credentials are for an S3 bucket that is shared between dev, staging, and prod; so you will use the same key id and secret key for each environment. You will need to supply the credentials in all three `secrets.auto.tfvars` files.

    For example, your `terraform/dev/secrets.auto.tfvars` file should now look something like this:

    ```
    aws_access_key_id = "some-access-key-id"
    aws_secret_access_key = "some-secret-access-key"
    cf_user = "some-dev-user"
    cf_password = "some-dev-password"
    ```

    _Tip: If you have credentials in `~/.aws/credentials` you may need to clear them out or replace them to keep those AWS credentials from overriding secrets.auto.tfvars._

## Terraform workflow

_Tip: You run terraform files from the directory in which they are stored. For example, to instantiate a database described in `terraform/dev/main.tf` you would run all the commands below from `terraform/dev`._

1. **Initialize your working directory**

    The first time you are working in a new environment, for example, after cloning this repository, you will need to initialize a working directory containing Terraform configuration files using the `init` command. It is safe to run this command multiple times.

    ```bash
    terraform init
    ```

1. **Check that your state is clean**

    Terraform configuration files committed to the `main` branch should describe the infrastructure that is currently in use. This is described as a "clean state". Use the `plan` command to display a list of infrastructure that Terraform will need to update, delete or create to match what is in your local Terraform configuration files.
      - If state is clean, `plan` will not display any changes.
      - If state is not clean and you are working on a feature branch try merging in the main branch; your local terraform files might be behind the current/applied state. If `plan` still shows an unclean state, reach out to your fellow developers for clarification and advice on how to proceed. It is very likely that changes were accidentally applied and a developer is currently working on a fix.

    ```bash
    terraform plan
    ```

1. **Make changes and get feedback**

    Make any needed changes to your local Terraform configuration files. Open a PR for those changes. In your PR include the output from `terraform plan` so reviewers can see what resources will be updated, created and destroyed.

1. **Merge and apply changes immediately**

    _Tip: Before you merge your PR ensure you have enough time to sit and work through any unexpected problems that could arise. Database changes can take upwards of ten minutes to apply._

    Merge your PR into `main` and then **immediately** apply your changes. Always merge and apply in one sitting.

    ```bash
    terraform apply
    ```

<!-- Links -->

[cloudgov-deployer]: https://cloud.gov/docs/services/cloud-gov-service-account/
[cloudgov-service-keys]: https://cloud.gov/docs/services/s3/#interacting-with-your-s3-bucket-from-outside-cloudgov
[tf]: https://www.terraform.io/downloads.html
[tf-vars]: https://www.terraform.io/docs/configuration/variables.html#variable-definitions-tfvars-files
